// automatically generated by Xtext
grammar ac.soton.xeventb.camillex.EventBComponent with org.eclipse.xtext.common.Terminals

// This does not work due to the nested package 
//import "http://emf.eventb.org/models/core/machine/2014" 
//import "http://emf.eventb.org/models/core/2014" as core
//import "http://emf.eventb.org/models/core/context/2014" as context
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "platform:/resource/org.eventb.emf.core/model/eventbcore.ecore" as eventbcore
import "platform:/resource/org.eventb.emf.core/model/eventbcore.ecore#//machine"as emachine
import "platform:/resource/org.eventb.emf.core/model/eventbcore.ecore#//context"as econtext
import "http://soton.ac.uk/models/eventb/inclusion/2017" as einclusion 

EventBComponent returns eventbcore::EventBNamedCommentedComponentElement:
	Machine | Context
;

/*
 * BEGIN: The terminal rules
 */
QualifiedName:
	ID('.'ID)?
;

// We override the ID terminal rules to support Unicode IDs.
@Override 
terminal ID: '^'?('a'..'z'|'A'..'Z'|'_'| 'i'..'ￜ') ('a'..'z'|'A'..'Z'|'_'| 'i'..'ￜ'|'0'..'9')*;

// Label starts with '@' and ends with ':'.
terminal LABEL returns ecore::EString:
	'@' !(':')+ ':'
;

/*
 * END: The terminal rules
 */

Machine returns emachine::Machine:
	{emachine::Machine}
	'machine' name=ID
	( extensions+= Includes*)
    ('refines' refines+=[emachine::Machine])?
	('sees' sees+=[econtext::Context]+)?
    ('variables' variables+=Variable+)?
	('invariants' invariants+=Invariant+)?
	('variant' variant=Variant)?
	('events' events+=Event (events+=Event)*)?
	('end')
;

Includes returns einclusion::MachineInclusion:
	{einclusion::MachineInclusion}
	('includes'abstractMachine = [emachine::Machine|QualifiedName])
	('to' concreteMachine = [emachine::Machine])? 
    ('as' prefixes += ID (prefixes += ID)*)? 
;

Variable returns emachine::Variable:
	{emachine::Variable}
	name=ID
;

Invariant returns emachine::Invariant:
	{emachine::Invariant}
	name=LABEL predicate=XPredicate(theorem?='theorem')?	
;

Variant returns emachine::Variant:
	{emachine::Variant}
	expression= XPredicate
;

Event returns emachine::Event:
	{emachine::Event}
	name=ID
	(
		(extended?='extended')? &
		(convergence=Convergence)?
	)
	( extensions+= EventSync*)
	('refines' refines+=[emachine::Event]+)?
	
	(
		('with' witnesses+=Witness+)?
		'begin'
			actions+=Action+
		|	
		'when'
			guards+=Guard+
		('with' witnesses+=Witness+)?
		('then'
			actions+=Action+)?
		|
		'any'
			parameters+=Parameter+
		'where'
			guards+=Guard+
		('with' witnesses+=Witness+)?
		('then'
			actions+=Action+)?
	)?	
	'end'
;

EventSync returns einclusion::EventSynchronisation:
	{einclusion::EventSynchronisation}
	('synchronises' (prefix=ID'.')?synchronisedEvent = [emachine::Event])
;

enum Convergence returns emachine::Convergence:
				ordinary = 'ordinary' | convergent = 'convergent' | anticipated = 'anticipated'
;

Parameter returns emachine::Parameter:
	{emachine::Parameter}
	name=ID
;

Guard returns emachine::Guard:
	{emachine::Guard}
	name=LABEL predicate= XPredicate (theorem?='theorem')?
;

Witness returns emachine::Witness:
	{emachine::Witness}
	name=LABEL predicate= XPredicate
;

Action returns emachine::Action:
	{emachine::Action}
	name=LABEL action= XPredicate
;

XPredicate returns ecore::EString:
	(
		EVENTB_IDENTIFIER_KEYWORD |
		EVENTB_PREDICATE_SYMBOLS |
		EVENTB_EXPRESSION_SYMBOLS |
		ID |
		INT
	)+ 
;

EVENTB_IDENTIFIER_KEYWORD returns ecore::EString:
	'BOOL' |
	'FALSE' |
	'TRUE' |
	'bool' |
	'card' |
	'dom' |
	'finite' |
	'id' |
	'inter' |
	'max' |
	'min' |
	'mod' |
	'pred' |
	'prj1' |
	'prj2' |
	'ran' |
	'succ' |
	'union' |
	'ℕ1' |
	'ℕ' |
	'ℙ1' |
	'ℙ' |
	'ℤ'
;

EVENTB_PREDICATE_SYMBOLS returns ecore::EString:
	'(' | // Predicate calculus symbols
	')' |
	'⇔' | 
	'⇒' |
	'∧' | '&' |
	'∨' |
	'¬' |
	'⊤' |
	'⊥' |
	'∀' | '!' |
	'∃' | '#' |
	',' |
	'·' | '.' |
	'=' | // Build predicates from expressions
	'≠' |
	'≤' |
	'<' |
	'≥' |
	'>' |
	'∈' | ':' | // Include this for Rodin keyboard
	'∉' | 
	'⊂' |
	'⊄' |
	'⊆' |
	'⊈' |
	'partition' // This is missing from the Rodin D7 deliverable
;

EVENTB_EXPRESSION_SYMBOLS returns ecore::EString:
	'↔' | // Symbols for building set of relations
	'' |
	'' |
	'' |
	'⇸' |
	'→' |
	'⤔' |
	'↣' |
	'⤀' |
	'↠' |
	'⤖' |
	'{' | // Symbols for manipulating sets
	'}' |
	'↦' |
	'∅' |
	'∩' |
	'∪' |
	'∖' |
	'×' |
	'[' | // Symbols for manipulating functions and relations
	']' |
	'' |
	'∘' |
	';' |
	'⊗' |
	'∥' |
	'∼' |
	'◁' |
	'⩤' |
	'▷' |
	'⩥' |
	'λ' | '%' // Symbols for quantified expressions
	'⋂' |
	'⋃' |
	'∣' |
	'‥' | // Symbols for arithmetic expressions
	'+' |
	'−' | '-' |
	'∗' | '*' |
	'÷' | '/' | 
	'^' |
	'\\' // Allowed for LaTeX combos
;

Context returns econtext::Context:
	{econtext::Context}
	'context' name=ID
	('extends' extends+=[econtext::Context |QualifiedName]+)?
	('sets' sets+=CarrierSet+)?
	('constants' constants+=Constant+)?
	('axioms' axioms+=Axiom+)?
	'end'
;

CarrierSet returns econtext::CarrierSet:
	{econtext::CarrierSet}
	name=ID
;


Constant returns econtext::Constant:
	{econtext::Constant}
	name=ID
;


Axiom returns econtext::Axiom:
	{econtext::Axiom}	
	name=LABEL predicate=XPredicate (theorem?='theorem')?
;