/**
 * generated by Xtext 2.14.0
 */
package ac.soton.xeventb.camillex.scoping;

import ac.soton.eventb.emf.inclusion.EventSynchronisation;
import ac.soton.eventb.emf.inclusion.InclusionPackage;
import ac.soton.eventb.emf.inclusion.MachineInclusion;
import ac.soton.xeventb.camillex.scoping.AbstractEventBComponentScopeProvider;
import ch.ethz.eventb.utils.EventBUtils;
import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.ArrayList;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eventb.core.IContextRoot;
import org.eventb.core.IEventBProject;
import org.eventb.core.IMachineRoot;
import org.eventb.core.basis.ContextRoot;
import org.eventb.core.basis.MachineRoot;
import org.eventb.emf.core.EventBElement;
import org.eventb.emf.core.context.Context;
import org.eventb.emf.core.context.ContextPackage;
import org.eventb.emf.core.machine.Event;
import org.eventb.emf.core.machine.Machine;
import org.eventb.emf.core.machine.MachinePackage;
import org.eventb.emf.persistence.EMFRodinDB;
import org.rodinp.core.IRodinProject;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class EventBComponentScopeProvider extends AbstractEventBComponentScopeProvider {
  /**
   * Getting the scope for the a reference feature of an input object.
   * 
   * @param context
   *          the current object.
   * @param reference
   *          the reference feature.
   */
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    try {
      if (((context instanceof Context) && Objects.equal(reference, ContextPackage.Literals.CONTEXT__EXTENDS))) {
        EMFRodinDB emfRodinDB = new EMFRodinDB();
        String prjName = emfRodinDB.getProjectName(((Context) context));
        IEventBProject eBPrj = EventBUtils.getEventBProject(prjName);
        IRodinProject rdPrj = eBPrj.getRodinProject();
        IContextRoot[] ctxRoots = rdPrj.<IContextRoot>getRootElementsOfType(ContextRoot.ELEMENT_TYPE);
        ArrayList<EventBElement> ctxs = new ArrayList<EventBElement>();
        for (final IContextRoot ctxRoot : ctxRoots) {
          {
            EventBElement ctx = emfRodinDB.loadEventBComponent(ctxRoot);
            ctxs.add(ctx);
          }
        }
        return Scopes.scopeFor(ctxs);
      }
      if (((context instanceof Event) && Objects.equal(reference, MachinePackage.Literals.EVENT__REFINES))) {
        EObject _rootContainer = EcoreUtil2.getRootContainer(context, true);
        final Machine mch = ((Machine) _rootContainer);
        final EList<Machine> refines = mch.getRefines();
        int _length = ((Object[])Conversions.unwrapArray(refines, Object.class)).length;
        boolean _notEquals = (_length != 0);
        if (_notEquals) {
          final Machine refinedMch = refines.get(0);
          final List<Event> refinedEvts = EcoreUtil2.<Event>getAllContentsOfType(refinedMch, Event.class);
          return Scopes.scopeFor(refinedEvts);
        }
        return super.getScope(context, reference);
      }
      if (((context instanceof Machine) && Objects.equal(reference, MachinePackage.Literals.MACHINE__SEES))) {
        EMFRodinDB emfRodinDB_1 = new EMFRodinDB();
        String prjName_1 = emfRodinDB_1.getProjectName(((Machine) context));
        IEventBProject eBPrj_1 = EventBUtils.getEventBProject(prjName_1);
        IRodinProject rdPrj_1 = eBPrj_1.getRodinProject();
        IContextRoot[] ctxRoots_1 = rdPrj_1.<IContextRoot>getRootElementsOfType(ContextRoot.ELEMENT_TYPE);
        ArrayList<EventBElement> ctxs_1 = new ArrayList<EventBElement>();
        for (final IContextRoot ctxRoot_1 : ctxRoots_1) {
          {
            EventBElement ctx = emfRodinDB_1.loadEventBComponent(ctxRoot_1);
            ctxs_1.add(ctx);
          }
        }
        return Scopes.scopeFor(ctxs_1);
      }
      if (((context instanceof Machine) && Objects.equal(reference, MachinePackage.Literals.MACHINE__REFINES))) {
        EMFRodinDB emfRodinDB_2 = new EMFRodinDB();
        String prjName_2 = emfRodinDB_2.getProjectName(((Machine) context));
        IEventBProject eBPrj_2 = EventBUtils.getEventBProject(prjName_2);
        IRodinProject rdPrj_2 = eBPrj_2.getRodinProject();
        IMachineRoot[] mchRoots = rdPrj_2.<IMachineRoot>getRootElementsOfType(MachineRoot.ELEMENT_TYPE);
        ArrayList<EventBElement> mchs = new ArrayList<EventBElement>();
        for (final IMachineRoot mchRoot : mchRoots) {
          {
            EventBElement mch_1 = emfRodinDB_2.loadEventBComponent(mchRoot);
            mchs.add(mch_1);
          }
        }
        return Scopes.scopeFor(mchs);
      }
      if (((context instanceof EventSynchronisation) && Objects.equal(reference, InclusionPackage.Literals.EVENT_SYNCHRONISATION__SYNCHRONISED_EVENT))) {
        EObject _rootContainer_1 = EcoreUtil2.getRootContainer(context, true);
        final Machine mch_1 = ((Machine) _rootContainer_1);
        final Iterable<MachineInclusion> mchExt = Iterables.<MachineInclusion>filter(mch_1.getExtensions(), MachineInclusion.class);
        ArrayList<Event> mchEvts = new ArrayList<Event>();
        for (final MachineInclusion mchInclusion : mchExt) {
          {
            Machine abstractMch = mchInclusion.getAbstractMachine();
            EventSynchronisation evtSync = ((EventSynchronisation) context);
            boolean _isEmpty = evtSync.getPrefix().isEmpty();
            boolean _not = (!_isEmpty);
            if (_not) {
              boolean _contains = mchInclusion.getPrefixes().contains(evtSync.getPrefix());
              if (_contains) {
                mchEvts.addAll(abstractMch.getEvents());
              }
            } else {
              mchEvts.addAll(abstractMch.getEvents());
            }
          }
        }
        return Scopes.scopeFor(mchEvts);
      }
      if (((context instanceof MachineInclusion) && 
        Objects.equal(reference, InclusionPackage.Literals.MACHINE_INCLUSION__ABSTRACT_MACHINE))) {
        return this.scopeForMachineInclusion(context, reference);
      }
      return null;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  /**
   * The scope for machine inclusion is the set of all (Rodin) machines
   * within the current project (reference using simple names) and the set
   * of all (XMachine) machines in the workspace (reference using qualified
   * name).
   * 
   * @author htson
   * @see EventBQualifiedNameProvider
   * @see EventBContainerManager
   * @since 0.0.8
   */
  private IScope scopeForMachineInclusion(final EObject context, final EReference reference) {
    try {
      final IScope superScope = super.getScope(context, reference);
      EMFRodinDB emfRodinDB = new EMFRodinDB();
      EObject _eContainer = context.eContainer();
      String prjName = emfRodinDB.getProjectName(((Machine) _eContainer));
      IEventBProject eBPrj = EventBUtils.getEventBProject(prjName);
      IRodinProject rdPrj = eBPrj.getRodinProject();
      IMachineRoot[] mchRoots = rdPrj.<IMachineRoot>getRootElementsOfType(MachineRoot.ELEMENT_TYPE);
      ArrayList<EventBElement> mchs = new ArrayList<EventBElement>();
      for (final IMachineRoot mchRoot : mchRoots) {
        {
          EventBElement mch = emfRodinDB.loadEventBComponent(mchRoot);
          mchs.add(mch);
        }
      }
      return Scopes.scopeFor(mchs, superScope);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}
